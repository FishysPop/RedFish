var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// src/biquad/Coefficients.ts
var FilterType = {
  SinglePoleLowPassApprox: 0,
  SinglePoleLowPass: 1,
  LowPass: 2,
  HighPass: 3,
  BandPass: 4,
  Notch: 5,
  AllPass: 6,
  LowShelf: 7,
  HighShelf: 8,
  PeakingEQ: 9
};
var Q_BUTTERWORTH = Math.SQRT1_2;
var Coefficients = class {
  constructor(data) {
    this.a1 = 0;
    this.a2 = 0;
    this.b0 = 0;
    this.b1 = 0;
    this.b2 = 0;
    if (data) {
      this.a1 = data.a1;
      this.a2 = data.a2;
      this.b0 = data.b0;
      this.b1 = data.b1;
      this.b2 = data.b2;
    }
  }
  static from(filter, samplingFreq, cutoffFreq, Q, dbGain = -10) {
    if (2 * cutoffFreq > samplingFreq) {
      throw new Error(`Cutoff frequency is too big!`);
    }
    if (Q < 0) {
      throw new Error(`Q may not be negative`);
    }
    const omega = 2 * Math.PI * cutoffFreq / samplingFreq;
    const bqf = typeof filter === "string" ? FilterType[filter] : filter;
    switch (bqf) {
      case FilterType.SinglePoleLowPassApprox: {
        const alpha = omega / (omega + 1);
        return new Coefficients({
          a1: alpha - 1,
          a2: 0,
          b0: alpha,
          b1: 0,
          b2: 0
        });
      }
      case FilterType.SinglePoleLowPass: {
        const omega_t = Math.tan(omega / 2);
        const a0 = 1 + omega_t;
        return new Coefficients({
          a1: (omega_t - 1) / a0,
          a2: 0,
          b0: omega_t / a0,
          b1: omega_t / a0,
          b2: 0
        });
      }
      case FilterType.LowPass: {
        const omega_s = Math.sin(omega);
        const omega_c = Math.cos(omega);
        const alpha = omega_s / (2 * Q);
        const b0 = (1 - omega_c) * 0.5;
        const b1 = 1 - omega_c;
        const b2 = (1 - omega_c) * 0.5;
        const a0 = 1 + alpha;
        const a1 = -2 * omega_c;
        const a2 = 1 - alpha;
        const div = 1 / a0;
        return new Coefficients({
          a1: a1 * div,
          a2: a2 * div,
          b0: b0 * div,
          b1: b1 * div,
          b2: b2 * div
        });
      }
      case FilterType.HighPass: {
        const omega_s = Math.sin(omega);
        const omega_c = Math.cos(omega);
        const alpha = omega_s / (2 * Q);
        const b0 = (1 + omega_c) * 0.5;
        const b1 = -(1 + omega_c);
        const b2 = (1 + omega_c) * 0.5;
        const a0 = 1 + alpha;
        const a1 = -2 * omega_c;
        const a2 = 1 - alpha;
        const div = 1 / a0;
        return new Coefficients({
          a1: a1 * div,
          a2: a2 * div,
          b0: b0 * div,
          b1: b1 * div,
          b2: b2 * div
        });
      }
      case FilterType.Notch: {
        const omega_s = Math.sin(omega);
        const omega_c = Math.cos(omega);
        const alpha = omega_s / (2 * Q);
        const b0 = 1;
        const b1 = -2 * omega_c;
        const b2 = 1;
        const a0 = 1 + alpha;
        const a1 = -2 * omega_c;
        const a2 = 1 - alpha;
        const div = 1 / a0;
        return new Coefficients({
          a1: a1 * div,
          a2: a2 * div,
          b0: b0 * div,
          b1: b1 * div,
          b2: b2 * div
        });
      }
      case FilterType.BandPass: {
        const omega_s = Math.sin(omega);
        const omega_c = Math.cos(omega);
        const alpha = omega_s / (2 * Q);
        const b0 = omega_s / 2;
        const b1 = 0;
        const b2 = -(omega_s / 2);
        const a0 = 1 + alpha;
        const a1 = -2 * omega_c;
        const a2 = 1 - alpha;
        const div = 1 / a0;
        return new Coefficients({
          a1: a1 * div,
          a2: a2 * div,
          b0: b0 * div,
          b1: b1 * div,
          b2: b2 * div
        });
      }
      case FilterType.AllPass: {
        const omega_s = Math.sin(omega);
        const omega_c = Math.cos(omega);
        const alpha = omega_s / (2 * Q);
        const b0 = 1 - alpha;
        const b1 = -2 * omega_c;
        const b2 = 1 + alpha;
        const a0 = 1 + alpha;
        const a1 = -2 * omega_c;
        const a2 = 1 - alpha;
        return new Coefficients({
          a1: a1 / a0,
          a2: a2 / a0,
          b0: b0 / a0,
          b1: b1 / a0,
          b2: b2 / a0
        });
      }
      case FilterType.LowShelf: {
        const a = Math.pow(10, dbGain / 40);
        const omega_s = Math.sin(omega);
        const omega_c = Math.cos(omega);
        const alpha = omega_s / (2 * Q);
        const b0 = a * (a + 1 - (a - 1) * omega_c + 2 * alpha * Math.sqrt(a));
        const b1 = 2 * a * (a - 1 - (a + 1) * omega_c);
        const b2 = a * (a + 1 - (a - 1) * omega_c - 2 * alpha * Math.sqrt(a));
        const a0 = a + 1 + (a - 1) * omega_c + 2 * alpha * Math.sqrt(a);
        const a1 = -2 * (a - 1 + (a + 1) * omega_c);
        const a2 = a + 1 + (a - 1) * omega_c - 2 * alpha * Math.sqrt(a);
        return new Coefficients({
          a1: a1 / a0,
          a2: a2 / a0,
          b0: b0 / a0,
          b1: b1 / a0,
          b2: b2 / a0
        });
      }
      case FilterType.HighShelf: {
        const a = Math.pow(10, dbGain / 40);
        const omega_s = Math.sin(omega);
        const omega_c = Math.cos(omega);
        const alpha = omega_s / (2 * Q);
        const b0 = a * (a + 1 + (a - 1) * omega_c + 2 * alpha * Math.sqrt(a));
        const b1 = -2 * a * (a - 1 + (a + 1) * omega_c);
        const b2 = a * (a + 1 + (a - 1) * omega_c - 2 * alpha * Math.sqrt(a));
        const a0 = a + 1 - (a - 1) * omega_c + 2 * alpha * Math.sqrt(a);
        const a1 = 2 * (a - 1 - (a + 1) * omega_c);
        const a2 = a + 1 - (a - 1) * omega_c - 2 * alpha * Math.sqrt(a);
        return new Coefficients({
          a1: a1 / a0,
          a2: a2 / a0,
          b0: b0 / a0,
          b1: b1 / a0,
          b2: b2 / a0
        });
      }
      case FilterType.PeakingEQ: {
        const a = Math.pow(10, dbGain / 40);
        const omega_s = Math.sin(omega);
        const omega_c = Math.cos(omega);
        const alpha = omega_s / (2 * Q);
        const b0 = 1 + alpha * a;
        const b1 = -2 * omega_c;
        const b2 = 1 - alpha * a;
        const a0 = 1 + alpha / a;
        const a1 = -2 * omega_c;
        const a2 = 1 - alpha / a;
        return new Coefficients({
          a1: a1 / a0,
          a2: a2 / a0,
          b0: b0 / a0,
          b1: b1 / a0,
          b2: b2 / a0
        });
      }
      default:
        throw new TypeError(`Invalid filter type "${filter}"`);
    }
  }
};
__name(Coefficients, "Coefficients");

// src/biquad/Biquad.ts
var BiquadFilter = class {
  constructor(coefficients) {
    this.coefficients = coefficients;
    this.x1 = 0;
    this.x2 = 0;
    this.y1 = 0;
    this.y2 = 0;
    this.s1 = 0;
    this.s2 = 0;
  }
  setFilter(filter, options) {
    const coefficients = Coefficients.from(filter, options.fs, options.f0, options.Q, options.gain);
    this.update(coefficients);
  }
  update(coefficients) {
    this.coefficients = coefficients;
  }
  replace(coefficients) {
    this.coefficients = coefficients;
  }
  reset() {
    this.x1 = 0;
    this.x2 = 0;
    this.y1 = 0;
    this.y2 = 0;
    this.s1 = 0;
    this.s2 = 0;
  }
  run(input) {
    const { a1, a2, b0, b1, b2 } = this.coefficients;
    const out = b0 * input + b1 * this.x1 + b2 * this.x2 - a1 * this.y1 - a2 * this.y2;
    this.x2 = this.x1;
    this.x1 = input;
    this.y2 = this.y1;
    this.y1 = out;
    return out;
  }
  runTransposed(input) {
    const { a1, a2, b0, b1, b2 } = this.coefficients;
    const out = this.s1 + b0 * input;
    this.s1 = this.s2 + b1 * input - a1 * out;
    this.s2 = b2 * input - a2 * out;
    return out;
  }
};
__name(BiquadFilter, "BiquadFilter");

// src/utils/Frequency.ts
var Frequency = class {
  constructor(__val) {
    this.__val = __val;
    if (typeof __val !== "number" || isNaN(__val) || __val === Infinity)
      throw new TypeError("Frequency value must be a number");
    if (this.__val < 0)
      throw new Error(`Frequency value cannot be negative (${__val})`);
  }
  khz() {
    return this.__val * 1e3;
  }
  mhz() {
    return this.__val * 1e6;
  }
  hz() {
    return this.__val;
  }
  dt() {
    return 1 / this.__val;
  }
  valueOf() {
    return this.__val;
  }
  toString() {
    return `${this.__val}Hz`;
  }
  toJSON() {
    return this.toString();
  }
};
__name(Frequency, "Frequency");

// src/utils/PCMTransformer.ts
import { Transform } from "stream";
var PCMTransformer = class extends Transform {
  constructor(options = {}) {
    super(options);
    this.type = "s16le";
    this.disabled = false;
    this.sampleRate = 48e3;
    this.onUpdate = /* @__PURE__ */ __name(() => {
    }, "onUpdate");
    options.type ?? (options.type = "s16le");
    this.disabled = !!options.disabled;
    if (typeof options.sampleRate === "number" && options.sampleRate > 0) {
      this.sampleRate = options.sampleRate;
    }
    switch (options.type) {
      case "s16be":
      case "s16le":
        this.type = options.type;
        this.bits = 16;
        break;
      case "s32be":
      case "s32le":
        this.type = options.type;
        this.bits = 32;
        break;
      default:
        throw new TypeError(`Expected type to be one of ${["s16be", "s16le", "s32be", "s32le"].join(", ")}, got "${options.type}"`);
    }
    this.bytes = this.bits / 8;
    this.extremum = Math.pow(2, this.bits - 1);
  }
  disable() {
    this.disabled = true;
  }
  enable() {
    this.disabled = false;
  }
  toggle() {
    this.disabled = !this.disabled;
  }
  _readInt(buffer, index) {
    const method = `readInt${this.type.substring(1).toUpperCase()}`;
    return buffer[method](index);
  }
  _writeInt(buffer, int, index) {
    const method = `writeInt${this.type.substring(1).toUpperCase()}`;
    return buffer[method](int, index);
  }
  clamp(val, max = this.extremum - 1, min = -this.extremum) {
    return Math.min(max, Math.max(min, val));
  }
  setSampleRate(rate) {
    this.sampleRate = rate;
    return;
  }
};
__name(PCMTransformer, "PCMTransformer");

// src/biquad/BiquadStream.ts
var BiquadStream = class extends PCMTransformer {
  constructor(options = {}) {
    super(options);
    this.cutoff = 80;
    this.gain = 0;
    this.Q = Q_BUTTERWORTH;
    if ("cutoff" in options)
      this.cutoff = options.cutoff;
    if ("gain" in options)
      this.gain = options.gain;
    if ("Q" in options)
      this.Q = options.Q;
    if ("biquadFilter" in options) {
      if (typeof options.biquadFilter === "string" || typeof options.biquadFilter === "number")
        this.biquadFilter = options.filter;
      if (this.biquadFilter != null) {
        this.biquad = new BiquadFilter(Coefficients.from(this.biquadFilter, this.sampleRate, this.cutoff, this.Q, this.gain));
      }
    }
  }
  get filter() {
    return this.biquadFilter;
  }
  set filter(f) {
    if (f == null || typeof f === "string" || typeof f === "number") {
      this.update({ filter: f });
    } else {
      throw new TypeError(`Invalid biquad filter type "${f}"`);
    }
  }
  getFilterName() {
    if (this.biquadFilter == null)
      return null;
    if (typeof this.biquadFilter === "string")
      return this.biquadFilter;
    return Object.entries(FilterType).find((r) => r[1] === this.biquadFilter)?.[0];
  }
  update(options) {
    if ("cutoff" in options)
      this.cutoff = options.cutoff;
    if ("gain" in options)
      this.gain = options.gain;
    if ("Q" in options)
      this.Q = options.Q;
    if ("filter" in options)
      this.biquadFilter = options.filter;
    if (this.biquadFilter != null) {
      this.biquad = new BiquadFilter(Coefficients.from(this.biquadFilter, this.sampleRate, this.cutoff, this.Q, this.gain));
    }
    this.onUpdate?.();
  }
  setFilter(filter) {
    this.update({ filter });
  }
  setQ(Q) {
    this.update({ Q });
  }
  setCutoff(f0) {
    this.update({ cutoff: f0 });
  }
  setGain(dB) {
    this.update({ gain: dB });
  }
  _transform(chunk, encoding, callback) {
    if (this.disabled || !this.biquad) {
      this.push(chunk);
      return callback();
    }
    const endIndex = Math.floor(chunk.length / 2) * 2;
    const { bytes } = this;
    for (let sampleIndex = 0; sampleIndex < endIndex; sampleIndex += bytes) {
      const int = this._readInt(chunk, sampleIndex);
      const result = this.biquad.run(int);
      this._writeInt(chunk, this.clamp(result), sampleIndex);
    }
    this.push(chunk);
    return callback();
  }
};
__name(BiquadStream, "BiquadStream");

// src/equalizer/ChannelProcessor.ts
var ChannelProcessor = class {
  constructor(bandMultipliers) {
    this.history = new Array(Equalizer.BAND_COUNT * 6).fill(0);
    this.bandMultipliers = bandMultipliers;
    this.current = 0;
    this.m1 = 2;
    this.m2 = 1;
  }
  processInt(int) {
    let result = int * 0.25;
    for (let bandIndex = 0; bandIndex < Equalizer.BAND_COUNT; bandIndex++) {
      const x = bandIndex * 6;
      const y = x + 3;
      const coefficients = Equalizer.Coefficients48000[bandIndex];
      const bandResult = coefficients.alpha * (int - this.history[x + this.m2]) + coefficients.gamma * this.history[y + this.m1] - coefficients.beta * this.history[y + this.m2];
      this.history[x + this.current] = int;
      this.history[y + this.current] = bandResult;
      result += bandResult * this.bandMultipliers[bandIndex];
    }
    const val = result * 4;
    return val;
  }
  process(samples, extremum = 131072, bytes = 2, readInt, writeInt) {
    const endIndex = Math.floor(samples.length / 2) * 2;
    for (let sampleIndex = 0; sampleIndex < endIndex; sampleIndex += bytes) {
      const sample = readInt?.(samples, sampleIndex) ?? samples.readInt16LE(sampleIndex);
      const result = this.processInt(sample);
      const val = Math.min(extremum - 1, Math.max(-extremum, result));
      writeInt?.(samples, val, sampleIndex) ?? samples.writeInt16LE(val, sampleIndex);
      this.step();
    }
    return samples;
  }
  step() {
    if (++this.current === 3) {
      this.current = 0;
    }
    if (++this.m1 === 3) {
      this.m1 = 0;
    }
    if (++this.m2 === 3) {
      this.m2 = 0;
    }
  }
  reset() {
    this.history.fill(0);
  }
};
__name(ChannelProcessor, "ChannelProcessor");

// src/equalizer/Coefficients.ts
var EqualizerCoefficients = class {
  constructor(beta, alpha, gamma) {
    this.beta = beta;
    this.alpha = alpha;
    this.gamma = gamma;
  }
  setBeta(v) {
    this.beta = v;
  }
  setAlpha(v) {
    this.alpha = v;
  }
  setGamma(v) {
    this.gamma = v;
  }
  toJSON() {
    const { alpha, beta, gamma } = this;
    return { alpha, beta, gamma };
  }
};
__name(EqualizerCoefficients, "EqualizerCoefficients");

// src/equalizer/EqualizerConfiguration.ts
var EqualizerConfiguration = class {
  constructor(bandMultipliers) {
    this.bandMultipliers = bandMultipliers;
  }
  setGain(band, value) {
    if (this.isValidBand(band)) {
      this.bandMultipliers[band] = Math.max(Math.min(value, 1), -0.25);
    }
  }
  getGain(band) {
    if (this.isValidBand(band)) {
      return this.bandMultipliers[band];
    } else {
      return 0;
    }
  }
  isValidBand(band) {
    return band >= 0 && band < this.bandMultipliers.length;
  }
};
__name(EqualizerConfiguration, "EqualizerConfiguration");

// src/equalizer/Equalizer.ts
var Equalizer = class extends EqualizerConfiguration {
  constructor(channelCount, bandMultipliers) {
    super(bandMultipliers);
    this.channels = [];
    this.channelCount = channelCount;
    this.channels = this.createChannelProcessor();
  }
  createChannelProcessor() {
    return Array.from({ length: this.channelCount }, () => {
      return new ChannelProcessor(this.bandMultipliers);
    });
  }
  process(input) {
    return this.channels.map((c, i) => {
      const { data, extremum, readInt, writeInt, bytes } = input[i];
      return c.process(data, extremum, bytes, readInt, writeInt);
    });
  }
};
__name(Equalizer, "Equalizer");
Equalizer.BAND_COUNT = 15;
Equalizer.SAMPLE_RATE = 48e3;
Equalizer.Coefficients48000 = [
  new EqualizerCoefficients(0.99847546664, 76226668143e-14, 1.9984647656),
  new EqualizerCoefficients(0.99756184654, 0.0012190767289, 1.9975344645),
  new EqualizerCoefficients(0.99616261379, 0.0019186931041, 1.9960947369),
  new EqualizerCoefficients(0.99391578543, 0.0030421072865, 1.9937449618),
  new EqualizerCoefficients(0.99028307215, 0.0048584639242, 1.9898465702),
  new EqualizerCoefficients(0.98485897264, 0.0075705136795, 1.9837962543),
  new EqualizerCoefficients(0.97588512657, 0.012057436715, 1.9731772447),
  new EqualizerCoefficients(0.96228521814, 0.018857390928, 1.9556164694),
  new EqualizerCoefficients(0.94080933132, 0.029595334338, 1.9242054384),
  new EqualizerCoefficients(0.90702059196, 0.046489704022, 1.8653476166),
  new EqualizerCoefficients(0.85868004289, 0.070659978553, 1.7600401337),
  new EqualizerCoefficients(0.78409610788, 0.10795194606, 1.5450725522),
  new EqualizerCoefficients(0.68332861002, 0.15833569499, 1.1426447155),
  new EqualizerCoefficients(0.55267518228, 0.22366240886, 0.40186190803),
  new EqualizerCoefficients(0.41811888447, 0.29094055777, -0.70905944223)
];

// src/equalizer/EqualizerStream.ts
var EqualizerStream = class extends PCMTransformer {
  constructor(options) {
    super(options);
    this.bandMultipliers = new Array(Equalizer.BAND_COUNT).fill(0);
    options = Object.assign(
      {},
      {
        bandMultiplier: [],
        channels: 1
      },
      options || {}
    );
    this.equalizer = new Equalizer(options.channels || 1, this.bandMultipliers);
    if (Array.isArray(options.bandMultiplier))
      this._processBands(options.bandMultiplier);
  }
  _processBands(multiplier) {
    for (const mul of multiplier) {
      if (mul.band > Equalizer.BAND_COUNT - 1 || mul.band < 0)
        throw new RangeError(`Band value out of range. Expected >0 & <${Equalizer.BAND_COUNT - 1}, received "${mul.band}"`);
      this.equalizer.setGain(mul.band, mul.gain);
    }
    this.onUpdate?.();
  }
  _transform(chunk, encoding, callback) {
    if (this.disabled) {
      this.push(chunk);
      return callback();
    }
    this.equalizer.process([
      {
        data: chunk,
        extremum: this.extremum,
        readInt: (b, idx) => this._readInt(b, idx),
        writeInt: (b, i, idx) => this._writeInt(b, i, idx),
        bytes: this.bytes
      }
    ]);
    this.push(chunk);
    return callback();
  }
  getEQ() {
    return this.bandMultipliers.map((m, i) => ({
      band: i,
      gain: m
    }));
  }
  setEQ(bands) {
    this._processBands(bands);
  }
  resetEQ() {
    this._processBands(
      Array.from(
        {
          length: Equalizer.BAND_COUNT
        },
        (_, i) => ({
          band: i,
          gain: 0
        })
      )
    );
  }
};
__name(EqualizerStream, "EqualizerStream");

// src/audio/MonoStereoTransformer.ts
var MonoStereoTransformer = class extends PCMTransformer {
  constructor(options) {
    super(options);
    if (!["m2s", "s2m"].includes(options?.strategy)) {
      throw new TypeError(`Strategy must be "m2s" or "s2m"`);
    }
    this.strategy = options.strategy;
  }
  setStrategy(strategy) {
    this.strategy = strategy;
  }
  _transform(chunk, encoding, callback) {
    if (this.disabled) {
      this.push(chunk);
      return callback();
    }
    const len = Math.floor(chunk.length / 2) * 2;
    if (this.strategy === "m2s") {
      this.push(this.toStereo(chunk, len));
    } else {
      this.push(this.toMono(chunk, len));
    }
    return callback();
  }
  toStereo(sample, len) {
    const bytes = this.bytes;
    const stereoBuffer = Buffer.alloc(len * 2);
    for (let i = 0; i < len; i += bytes) {
      stereoBuffer[i * 2 + 0] = sample[i];
      stereoBuffer[i * 2 + 1] = sample[i + 1];
      stereoBuffer[i * 2 + 2] = sample[i];
      stereoBuffer[i * 2 + 3] = sample[i + 1];
    }
    return stereoBuffer;
  }
  toMono(sample, len) {
    const bytes = this.bytes;
    const monoBuffer = Buffer.alloc(Math.floor(len / 2));
    for (let i = 0; i < len; i += bytes) {
      monoBuffer[i] = sample[i * 2 + 0];
      monoBuffer[i + 1] = sample[i * 2 + 1];
    }
    return monoBuffer;
  }
};
__name(MonoStereoTransformer, "MonoStereoTransformer");

// src/audio/transformers/index.ts
var transformers_exports = {};
__export(transformers_exports, {
  applyBiquad: () => applyBiquad,
  applyEqualization: () => applyEqualization,
  applyPulsator: () => applyPulsator,
  applyTremolo: () => applyTremolo,
  applyVibrato: () => applyVibrato,
  applyVolume: () => applyVolume
});

// src/audio/transformers/biquad.ts
function applyBiquad(filterer, int) {
  return filterer.run(int);
}
__name(applyBiquad, "applyBiquad");

// src/audio/transformers/dsp.ts
function applyPulsator(config, int, channel) {
  const sin = Math.sin(config.x);
  const currentChannelVal = channel === 0 ? sin : -sin;
  const res = int * (currentChannelVal + 1) / 2;
  config.x += config.dI;
  return res;
}
__name(applyPulsator, "applyPulsator");
function applyTremolo(config, int, sampleRate) {
  const fOffset = 1 - config.depth;
  const modSignal = fOffset + config.depth * Math.sin(config.phase);
  config.phase += 2 * Math.PI / sampleRate * config.frequency;
  return modSignal * int;
}
__name(applyTremolo, "applyTremolo");
function applyVibrato(config, int, sampleRate) {
  const fOffset = 1 - config.depth;
  const modSignal = fOffset + config.depth * Math.sin(2 * Math.PI * config.phase);
  config.phase += 2 * Math.PI / sampleRate * config.frequency;
  return modSignal * int;
}
__name(applyVibrato, "applyVibrato");
function applyVolume(vol, int) {
  return vol * int;
}
__name(applyVolume, "applyVolume");

// src/audio/transformers/equalizer.ts
function applyEqualization(eq, int) {
  const processor = eq.channels[0];
  const result = processor.processInt(int);
  processor.step();
  return result;
}
__name(applyEqualization, "applyEqualization");

// src/audio/AudioFilter.ts
var AudioFilters = {
  "8D": "8D",
  Tremolo: "Tremolo",
  Vibrato: "Vibrato"
};
var AF_NIGHTCORE_RATE = 1.3;
var AF_VAPORWAVE_RATE = 0.8;
var BASS_EQ_BANDS = Array.from({ length: 3 }, (_, i) => ({
  band: i,
  gain: 0.25
}));
var AudioFilter = class extends PCMTransformer {
  constructor(options) {
    super(options);
    this.filters = [];
    this.targetSampleRate = this.sampleRate;
    this.totalSamples = 0;
    this._processedSamples = 0;
    this.pulsatorConfig = {
      hz: 0.02,
      x: 0,
      dI: 3926990816987241e-21
    };
    this.tremoloConfig = {
      phase: 0,
      depth: 0.5,
      frequency: 5
    };
    this.vibratoConfig = {
      phase: 0,
      depth: 0.5,
      frequency: 5
    };
    if (options && Array.isArray(options.filters)) {
      this.setFilters(options.filters);
    }
    this.onUpdate?.();
  }
  setTargetSampleRate(rate) {
    this.targetSampleRate = rate || this.sampleRate;
    return;
  }
  setPulsator(hz) {
    hz /= 4;
    this.pulsatorConfig.hz = hz;
    const samplesPerCycle = this.targetSampleRate / (hz * 2 * Math.PI);
    this.pulsatorConfig.dI = hz === 0 ? 0 : 1 / samplesPerCycle;
    this.onUpdate?.();
  }
  get pulsator() {
    return this.pulsatorConfig.hz;
  }
  setTremolo({ depth = this.tremoloConfig.depth, frequency = this.tremoloConfig.frequency, phase = this.tremoloConfig.phase }) {
    if (typeof depth === "number")
      this.tremoloConfig.depth = depth;
    if (typeof frequency === "number")
      this.tremoloConfig.frequency = frequency;
    if (typeof phase === "number")
      this.tremoloConfig.phase = phase;
    this.onUpdate?.();
  }
  setVibrato({ depth = this.vibratoConfig.depth, frequency = this.vibratoConfig.frequency, phase = this.vibratoConfig.phase }) {
    if (typeof depth === "number")
      this.vibratoConfig.depth = depth;
    if (typeof frequency === "number")
      this.vibratoConfig.frequency = frequency;
    if (typeof phase === "number")
      this.vibratoConfig.phase = phase;
    this.onUpdate?.();
  }
  get tremolo() {
    return this.tremoloConfig;
  }
  setFilters(filters) {
    if (!Array.isArray(filters) || !filters.every((r) => r in AudioFilters)) {
      return false;
    }
    this.filters = filters;
    this.onUpdate?.();
    return true;
  }
  seek(duration) {
    throw new Error("Not Implemented");
  }
  _transform(chunk, encoding, callback) {
    this._processedSamples++;
    this.totalSamples += chunk.length / this.bits;
    if (this.disabled || !this.filters.length) {
      return callback(null, chunk);
    }
    const len = Math.floor(chunk.length / 2) * 2;
    const { bytes } = this;
    let L = false;
    for (let i = 0; i < len; i += bytes) {
      const int = this._readInt(chunk, i);
      const value = this.applyFilters(int, +(L = !L));
      this._writeInt(chunk, this.clamp(value), i);
    }
    this.push(chunk);
    return callback();
  }
  get currentSampleRate() {
    return this.targetSampleRate || this.sampleRate;
  }
  get estimatedDuration() {
    return this.totalSamples / this.targetSampleRate * 1e3;
  }
  get currentDuration() {
    return this._processedSamples * 1e3 / this.targetSampleRate;
  }
  applyFilters(byte, channel) {
    if (this.filters.length) {
      for (const filter of this.filters) {
        if (filter === "8D") {
          byte = applyPulsator(this.pulsatorConfig, byte, channel);
        }
        if (filter === "Tremolo") {
          byte = applyTremolo(this.tremoloConfig, byte, this.currentSampleRate);
        }
        if (filter === "Vibrato") {
          byte = applyVibrato(this.vibratoConfig, byte, this.currentSampleRate);
        }
      }
    }
    return byte;
  }
};
__name(AudioFilter, "AudioFilter");

// src/audio/PCMResampler.ts
var PCMResampler = class extends PCMTransformer {
  constructor(options) {
    super(options);
    this.targetSampleRate = this.sampleRate;
    if (options?.targetSampleRate)
      this.targetSampleRate = options.targetSampleRate;
  }
  get AF_NIGHTCORE() {
    return 64e3;
  }
  get AF_VAPORWAVE() {
    return 32e3;
  }
  setTargetSampleRate(rate) {
    if (rate === "NIGHTCORE" || rate === "VAPORWAVE")
      rate = this[`AF_${rate}`];
    if (typeof rate !== "number")
      return false;
    this.targetSampleRate = rate;
    this.onUpdate?.();
    return true;
  }
  _transform(chunk, _, cb) {
    if (this.disabled || this.sampleRate === this.targetSampleRate) {
      this.push(chunk);
      return cb();
    }
    this.push(chunk);
    cb();
  }
};
__name(PCMResampler, "PCMResampler");

// src/audio/VolumeTransformer.ts
var VolumeTransformer = class extends PCMTransformer {
  constructor(options) {
    super(options);
    this._volume = 1;
    if (typeof options?.volume === "number") {
      this.setVolume(options.volume);
    }
  }
  get volume() {
    return this._volume * 100;
  }
  set volume(volume) {
    this.setVolume(volume);
  }
  setVolume(volume) {
    if (typeof volume !== "number" || isNaN(volume))
      return false;
    if (volume < 0)
      volume = 0;
    if (!isFinite(volume))
      volume = 100;
    this._volume = volume / 100;
    this.onUpdate?.();
    return true;
  }
  _transform(chunk, encoding, callback) {
    if (this.disabled || this._volume === 1) {
      this.push(chunk);
      return callback();
    }
    const len = Math.floor(chunk.length / 2) * 2;
    const { bytes } = this;
    for (let i = 0; i < len; i += bytes) {
      const int = this._readInt(chunk, i);
      const amp = this.clamp(int * this._volume);
      this._writeInt(chunk, amp, i);
    }
    this.push(chunk);
    return callback();
  }
  toString() {
    return `${this.volume}%`;
  }
};
__name(VolumeTransformer, "VolumeTransformer");

// src/FiltersChainBuilder.ts
import { pipeline } from "stream";
var FiltersChain = class {
  constructor(presets = {}) {
    this.presets = presets;
    this.equalizer = null;
    this.filters = null;
    this.biquad = null;
    this.volume = null;
    this.resampler = null;
    this.destination = null;
    this.source = null;
    this.onUpdate = /* @__PURE__ */ __name(() => null, "onUpdate");
    this.onError = /* @__PURE__ */ __name(() => null, "onError");
  }
  create(src, presets = this.presets) {
    this.destroy();
    this.source = src;
    const equalizerStream = new EqualizerStream(presets.equalizer);
    const dspStream = new AudioFilter(presets.dsp);
    const biquadStream = new BiquadStream(presets.biquad);
    const volumeTransformer = new VolumeTransformer(presets.volume);
    this.equalizer = equalizerStream;
    this.filters = dspStream;
    this.biquad = biquadStream;
    this.volume = volumeTransformer;
    equalizerStream.onUpdate = this.onUpdate;
    dspStream.onUpdate = this.onUpdate;
    biquadStream.onUpdate = this.onUpdate;
    volumeTransformer.onUpdate = this.onUpdate;
    this.destination = pipeline(src, equalizerStream, dspStream, biquadStream, volumeTransformer, (err) => {
      if (err) {
        this.destroy();
        if (!err.message.includes("ERR_STREAM_PREMATURE_CLOSE"))
          this.onError(err);
      }
    });
    this.destination.once("close", this.destroy.bind(this));
    return this.destination;
  }
  destroy() {
    this.equalizer?.destroy();
    this.biquad?.destroy();
    this.filters?.destroy();
    this.volume?.destroy();
    this.destination?.destroy();
    this.source?.destroy();
    this.equalizer?.removeAllListeners();
    this.biquad?.removeAllListeners();
    this.filters?.removeAllListeners();
    this.volume?.removeAllListeners();
    this.destination?.removeAllListeners();
    this.source?.removeAllListeners();
    this.equalizer = null;
    this.biquad = null;
    this.filters = null;
    this.volume = null;
    this.destination = null;
    this.source = null;
  }
};
__name(FiltersChain, "FiltersChain");

// src/index.ts
var version = "0.2.1";
export {
  AF_NIGHTCORE_RATE,
  AF_VAPORWAVE_RATE,
  AudioFilter,
  AudioFilters,
  BASS_EQ_BANDS,
  BiquadFilter,
  BiquadStream,
  ChannelProcessor,
  Coefficients,
  Equalizer,
  EqualizerCoefficients,
  EqualizerConfiguration,
  EqualizerStream,
  FilterType,
  FiltersChain,
  Frequency,
  MonoStereoTransformer,
  transformers_exports as PCMAudioTransformer,
  PCMResampler,
  PCMTransformer,
  Q_BUTTERWORTH,
  VolumeTransformer,
  version
};
//# sourceMappingURL=index.mjs.map